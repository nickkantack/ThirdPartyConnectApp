(()=>{"use strict";let e;function t(t){if(!e)throw new Error(null!=t?t:"Attempted to get Global AmazonConnectProvider that has not been set.");return e}class s{constructor({config:e,proxyFactory:t}){if(!t)throw new Error("Attempted to get Proxy before setting up factory");if(!e)throw new Error("Failed to include config");this.proxyFactory=t,this._config=e}getProxy(){return this.proxy||(this.proxy=this.proxyFactory(this),this.proxy.init()),this.proxy}get config(){return Object.assign({},this._config)}onError(e){this.getProxy().onError(e)}offError(e){this.getProxy().offError(e)}static initializeProvider(t){const s=new o({source:"core.amazonConnect.init",provider:t});if(this.isInitialized){const e="Error: Attempted to initialize provider more than one time.";throw s.error(e),new Error(e)}return function(t){if(e)throw new Error("Global Provider is already set");e=t}(t),this.isInitialized=!0,t.getProxy(),t}}s.isInitialized=!1;class r{constructor(e,t){this.timeoutMs=t,this.onCancelled=e,this.timeout=setTimeout((()=>this.handleCancel()),this.timeoutMs),this.status="running",this.logger=new o({source:"core.utility.timeout-tracker",mixin:()=>({timeoutMs:this.timeoutMs,timeoutTrackerStatus:this.status})})}static start(e,t){return new r(e,t)}complete(){switch(this.status){case"running":return this.handleComplete();case"completed":return this.logger.debug("TimeoutTracker already marked complete. No action."),!0;case"cancelled":return this.logger.info("Attempted to complete a TimeoutTracker that has already been cancelled"),!1}}isCancelled(){return"cancelled"===this.status}getStatus(){return this.status}handleCancel(){switch(this.status){case"running":this.status="cancelled",this.logger.info("TimeoutTracker has timed out. Invoking onCancelled Handler"),this.invokeOnCancelled();break;case"completed":this.logger.debug("Cancel operation for TimerTracker invoked after already completed. No action.");break;default:throw new Error("Cancel operation in TimerTracker called during an unexpected time.")}}handleComplete(){return this.status="completed",clearTimeout(this.timeout),!0}invokeOnCancelled(){try{this.onCancelled({timeoutMs:this.timeoutMs})}catch(e){this.logger.error("Error when attempting to invoke TimeoutTrackerCancelledHandler",{error:e})}}}var n;!function(e){e[e.trace=1]="trace",e[e.debug=2]="debug",e[e.info=3]="info",e[e.warn=4]="warn",e[e.error=5]="error"}(n||(n={}));class i{constructor(e){this.mixin=e}getTransformedData(e,t){return this.mixin?Object.assign(Object.assign({},null!=t?t:{}),this.mixin(null!=t?t:{},e)):t}}class o{constructor(e){this._proxy=null,this._logToConsoleLevel=null,this.loggerId=function(e){const t=new Uint8Array(Math.ceil(4));return crypto.getRandomValues(t),Array.from(t,(e=>e.toString(16).padStart(2,"0"))).join("").substring(0,8)}(),"string"==typeof e?(this.source=e,this.dataTransformer=new i(void 0)):(this.source=e.source,this.provider=e.provider,this.dataTransformer=new i(e.mixin),this.logOptions=e.options)}trace(e,t,s){this.log(n.trace,e,t,s)}debug(e,t,s){this.log(n.debug,e,t,s)}info(e,t,s){this.log(n.info,e,t,s)}warn(e,t,s){this.log(n.warn,e,t,s)}error(e,t,s){this.log(n.error,e,t,s)}log(e,t,s,r){const i=this.dataTransformer.getTransformedData(e,s);this.ignoreRemote(r)||this.getProxy().log({level:e,source:this.source,loggerId:this.loggerId,message:t,data:i}),this.applyDuplicateMessageToConsole(e,r)&&function(e,t,s){if(s)switch(e){case n.error:console.error(t,s);break;case n.warn:console.warn(t,s);break;case n.info:console.info(t,s);break;case n.debug:console.debug(t,s);break;case n.trace:console.trace(t,s);break;default:console.log(t,s)}else switch(e){case n.error:console.error(t);break;case n.warn:console.warn(t);break;case n.info:console.info(t);break;case n.debug:console.debug(t);break;case n.trace:console.trace(t);break;default:console.log(t)}}(e,t,i)}getProvider(){return this.provider?this.provider:t()}getProxy(){return this._proxy||(this._proxy=this.getProvider().getProxy()),this._proxy}applyDuplicateMessageToConsole(e,t){return(null==t?void 0:t.duplicateMessageToConsole)||this.getLogConsoleLevel()<=e}getLogConsoleLevel(){var e,t,s,r;return this._logToConsoleLevel||(this._logToConsoleLevel=(null===(e=this.logOptions)||void 0===e?void 0:e.minLogToConsoleLevelOverride)?this.logOptions.minLogToConsoleLevelOverride:null!==(r=null===(s=null===(t=this.getProvider().config)||void 0===t?void 0:t.logging)||void 0===s?void 0:s.minLogToConsoleLevel)&&void 0!==r?r:n.error),this._logToConsoleLevel}ignoreRemote(e){var t,s,r;return null!==(s=null===(t=this.logOptions)||void 0===t?void 0:t.remoteIgnore)&&void 0!==s&&s||null!==(r=null==e?void 0:e.remoteIgnore)&&void 0!==r&&r}}class a{constructor(){this.simpleSubscriptions=new Map,this.paramSubscriptions=new Map}add({namespace:e,key:t,parameter:s},r){var n,i,o,a,c;if(s){if(!this.paramSubscriptions.has(e))return void this.paramSubscriptions.set(e,new Map([[t,new Map([[s,r]])]]));if(!(null===(n=this.paramSubscriptions.get(e))||void 0===n?void 0:n.has(t)))return void(null===(i=this.paramSubscriptions.get(e))||void 0===i||i.set(t,new Map([[s,r]])));null===(a=null===(o=this.paramSubscriptions.get(e))||void 0===o?void 0:o.get(t))||void 0===a||a.set(s,r)}else{if(!this.simpleSubscriptions.has(e))return void this.simpleSubscriptions.set(e,new Map([[t,r]]));null===(c=this.simpleSubscriptions.get(e))||void 0===c||c.set(t,r)}}delete({namespace:e,key:t,parameter:s}){var r,n,i,o;s?(null===(n=null===(r=this.paramSubscriptions.get(e))||void 0===r?void 0:r.get(t))||void 0===n?void 0:n.delete(s))&&this.paramSubscriptions.get(e).get(t).size<1&&(null===(i=this.paramSubscriptions.get(e))||void 0===i||i.delete(t),this.paramSubscriptions.get(e).size<1&&this.paramSubscriptions.delete(e)):(null===(o=this.simpleSubscriptions.get(e))||void 0===o?void 0:o.delete(t))&&this.simpleSubscriptions.get(e).size<1&&this.simpleSubscriptions.delete(e)}get({namespace:e,key:t,parameter:s}){var r,n,i;return s?null===(i=null===(n=this.paramSubscriptions.get(e))||void 0===n?void 0:n.get(t))||void 0===i?void 0:i.get(s):null===(r=this.simpleSubscriptions.get(e))||void 0===r?void 0:r.get(t)}getOrAdd(e,t){let s=this.get(e);return s||(s=t(),this.add(e,s)),s}addOrUpdate(e,t,s){let r=this.get(e);return r=r?s(r):t(),this.add(e,r),r}getAllSubscriptions(){return[...Array.from(this.simpleSubscriptions.keys()).flatMap((e=>Array.from(this.simpleSubscriptions.get(e).keys()).flatMap((t=>({namespace:e,key:t}))))),...Array.from(this.paramSubscriptions.keys()).flatMap((e=>Array.from(this.paramSubscriptions.get(e).keys()).flatMap((t=>Array.from(this.paramSubscriptions.get(e).get(t).keys()).flatMap((s=>({namespace:e,key:t,parameter:s})))))))]}}class c{constructor(){this.map=new a}add(e,t){this.map.addOrUpdate(e,(()=>new Set([t])),(e=>e.add(t)))}delete(e,t){const s=this.map.get(e);s&&(s.delete(t),0===s.size&&this.map.delete(e))}get(e){var t;return[...null!==(t=this.map.get(e))&&void 0!==t?t:[]]}size(e){var t,s;return null!==(s=null===(t=this.map.get(e))||void 0===t?void 0:t.size)&&void 0!==s?s:0}isEmpty(e){return 0===this.size(e)}getAllSubscriptions(){return this.map.getAllSubscriptions()}}class l{constructor(){this.errorHandlers=new Set,this.logger=new o({source:"core.proxy.error"})}invoke(e){const{message:t,key:s,details:r,isFatal:n,connectionStatus:i}=e;this.logger.error(t,{key:s,details:r,isFatal:n,connectionStatus:i},{duplicateMessageToConsole:!0,remoteIgnore:!0}),[...this.errorHandlers].forEach((t=>{try{t(e)}catch(t){this.logger.error("An error occurred within a AmazonConnectErrorHandler",{handlerError:t,originalError:e})}}))}onError(e){this.errorHandlers.add(e)}offError(e){this.errorHandlers.delete(e)}}class d{constructor(){this.status="notConnected",this.changeHandlers=new Set,this.logger=new o({source:"core.proxy.connection-status-manager",mixin:()=>({status:this.status})})}getStatus(){return this.status}update(e){this.status=e.status,this.logger.debug("Proxy Connection Status Changed",{status:e.status}),[...this.changeHandlers].forEach((t=>{try{t(e)}catch(e){this.logger.error("An error occurred within a ProxyConnectionChangedHandler",{error:e})}}))}onChange(e){this.changeHandlers.add(e)}offChange(e){this.changeHandlers.delete(e)}}class h{constructor(e){this.provider=e,this.logger=new o({source:"core.proxy",mixin:()=>({proxyType:this.proxyType})}),this.status=new d,this.errorService=new l,this.upstreamMessageQueue=[],this.connectionEstablished=!1,this.isInitialized=!1,this.subscriptions=new c}init(){if(this.isInitialized)throw new Error("Proxy already initialized");this.isInitialized=!0,this.initProxy()}subscribe(e,t){this.subscriptions.add(e,t);const s={type:"subscribe",topic:e};this.sendOrQueueMessageToSubject(s)}unsubscribe(e,t){if(this.subscriptions.delete(e,t),this.subscriptions.isEmpty(e)){const t={type:"unsubscribe",topic:e};this.sendOrQueueMessageToSubject(t)}}log({level:e,source:t,message:s,loggerId:r,data:n}){const i=n?JSON.parse(JSON.stringify(n)):void 0,o={type:"log",level:e,time:new Date,source:t,message:s,loggerId:r,data:i,context:this.addContextToLogger()};this.sendOrQueueMessageToSubject(o)}sendLogMessage(e){"log"===e.type?(e.context=Object.assign(Object.assign({},e.context),this.addContextToLogger()),this.sendOrQueueMessageToSubject(e)):this.logger.error("Attempted to send invalid log message",{message:e})}sendOrQueueMessageToSubject(e){this.connectionEstablished?this.sendMessageToSubject(e):this.upstreamMessageQueue.push(e)}consumerMessageHandler(e){if(!this.isInitialized)return void this.logger.error("Attempted to process message from subject prior to proxy being initializing. Message not processed",{originalMessageEventData:e.data});const{data:t}=e;if(!("type"in t))return void this.logger.warn("Unknown inbound message",{originalMessageEventData:t});const s=t;this.handleMessageFromSubject(s)}handleMessageFromSubject(e){this.handleDefaultMessageFromSubject(e)}handleDefaultMessageFromSubject(e){switch(e.type){case"acknowledge":this.handleConnectionAcknowledge();break;case"publish":this.handlePublish(e);break;case"error":this.handleError(e);break;default:return void this.logger.error("Unknown inbound message",{originalMessageEventData:e})}}handleConnectionAcknowledge(){for(this.status.update({status:"ready"}),this.connectionEstablished=!0;this.upstreamMessageQueue.length;){const e=this.upstreamMessageQueue.shift();this.sendMessageToSubject(e)}}handlePublish(e){this.subscriptions.get(e.topic).map((t=>this.handleAsyncSubscriptionHandlerInvoke(t,e)))}handleError(e){if(e.isFatal){const{message:t,type:s}=e,r=function(e,t){var s={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(s[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(r=Object.getOwnPropertySymbols(e);n<r.length;n++)t.indexOf(r[n])<0&&Object.prototype.propertyIsEnumerable.call(e,r[n])&&(s[r[n]]=e[r[n]])}return s}(e,["message","type"]);this.status.update({status:"error",reason:t,details:r})}this.publishError({message:e.message,key:e.key,details:e.details,isFatal:e.isFatal,proxyStatus:e.status})}publishError(e){const t=Object.assign(Object.assign({},e),{connectionStatus:this.connectionStatus});this.errorService.invoke(t)}handleAsyncSubscriptionHandlerInvoke(e,{topic:t,data:s}){return r=this,n=void 0,o=function*(){try{yield e(s)}catch(e){this.logger.error("An error occurred when handling subscription",{topic:t,error:e})}},new((i=void 0)||(i=Promise))((function(e,t){function s(e){try{c(o.next(e))}catch(e){t(e)}}function a(e){try{c(o.throw(e))}catch(e){t(e)}}function c(t){var r;t.done?e(t.value):(r=t.value,r instanceof i?r:new i((function(e){e(r)}))).then(s,a)}c((o=o.apply(r,n||[])).next())}));var r,n,i,o}get connectionStatus(){return this.status.getStatus()}onError(e){this.errorService.onError(e)}offError(e){this.errorService.offError(e)}onConnectionStatusChange(e){this.status.onChange(e)}offConnectionStatusChange(e){this.status.offChange(e)}}class p{constructor(e,t){this.engineContext=e,this.moduleNamespace=t}get proxy(){if(!this.moduleProxy){const e=this.engineContext.getProxy(),t=this.moduleNamespace;this.moduleProxy=function(e,t){return{subscribe:(s,r)=>e.subscribe(Object.assign(Object.assign({},s),{namespace:t}),r),unsubscribe:(s,r)=>e.unsubscribe(Object.assign(Object.assign({},s),{namespace:t}),r),getProxyInfo:()=>({connectionStatus:e.connectionStatus,proxyType:e.proxyType}),onConnectionStatusChange:t=>e.onConnectionStatusChange(t),offConnectionStatusChange:t=>e.offConnectionStatusChange(t)}}(e,t)}return this.moduleProxy}createLogger(e){return this.engineContext.createLogger(e)}}class u{constructor(e){this.provider=e}getProxy(){return this.getProvider().getProxy()}getModuleContext(e){return new p(this,e)}getProvider(){return this.provider?this.provider:t()}createLogger(e){return new o(e)}}class g extends u{constructor(e,t,s){super(e),this.appInstanceId=t,this.appConfig=s}}var m=function(e,t,s,r){return new(s||(s=Promise))((function(n,i){function o(e){try{c(r.next(e))}catch(e){i(e)}}function a(e){try{c(r.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?n(e.value):(t=e.value,t instanceof s?t:new s((function(e){e(t)}))).then(o,a)}c((r=r.apply(e,t||[])).next())}))};class f{constructor(e){this.provider=e,this.startHandlers=new Set,this.stopHandlers=new Set,this.state={isRunning:!1},this.isCreated=!1,this.isDestroyed=!1,this.logger=new o({source:"app.lifecycleManager",provider:e,mixin:()=>({state:this.state,isCreated:this.isCreated,isDestroyed:this.isDestroyed})})}handleLifecycleChangeMessage(e){const t=new g(this.provider,e.appInstanceId,e.appConfig);this.state.appInstanceId=e.appInstanceId,this.state.appConfig=e.appConfig;const s={context:t};switch(e.stage){case"create":return this.handleCreate(s);case"start":return this.handleStart(s);case"stop":return this.handleStop(s);case"destroy":return this.handleDestroy(s)}}onStart(e,t){this.startHandlers.add(e),(null==t?void 0:t.invokeIfRunning)&&this.state.isRunning&&this.handleLifecycleChange(Object.assign(Object.assign({},this.getLifecycleChangeParams()),{stage:"start"}),(t=>e(t)),!1)}onStop(e){this.stopHandlers.add(e)}offStart(e){this.startHandlers.delete(e)}offStop(e){this.stopHandlers.delete(e)}get appState(){return Object.assign({},this.state)}handleCreate(e){var t;return m(this,void 0,void 0,(function*(){if(this.isDestroyed)return void this.logger.error("An attempt was Create after a Destroy. No Action",{appInstanceId:e.context.appInstanceId});if(this.isCreated)return void this.logger.error("An attempt was invoke Create after it was already invoked. No Action",{appInstanceId:e.context.appInstanceId});if(this.logger.debug("Begin Lifecycle Create",{appInstanceId:e.context.appInstanceId}),!(null===(t=this.provider.config)||void 0===t?void 0:t.onCreate)){const t="App did not specify an onCreated handler. This is required. Closing app",s={appInstanceId:e.context.appInstanceId};return this.logger.error(t,{appInstanceId:e.context.appInstanceId}),void this.provider.sendFatalError(t,s)}const{success:s}=yield this.handleLifecycleChange(Object.assign(Object.assign({},e),{stage:"create"}),(e=>this.provider.config.onCreate(e)),!0);s&&(this.isCreated=!0,this.sendLifecycleHandlerCompletedMessage(e.context.appInstanceId,"create"))}))}handleStart(e){return m(this,void 0,void 0,(function*(){if(this.isDestroyed)return void this.logger.error("An attempt was Start after a Destroy. No Action",{appInstanceId:e.context.appInstanceId});if(!this.isCreated)return void this.logger.error("An attempt was invoke Start before Create. No Action",{appInstanceId:e.context.appInstanceId});this.state.isRunning=!0,this.logger.info("Begin Lifecycle Start");const t=yield Promise.all([...this.startHandlers].map((t=>this.handleLifecycleChange(Object.assign(Object.assign({},e),{stage:"start"}),(e=>t(e)),!1))));this.logger.debug("Completed all start handlers",{count:this.startHandlers.size,errorCount:t.filter((({success:e})=>!e)).length})}))}handleStop(e){return m(this,void 0,void 0,(function*(){if(this.isDestroyed)return void this.logger.error("An attempt was Stop after a Destroy. No Action",{appInstanceId:e.context.appInstanceId});if(!this.isCreated)return void this.logger.error("An attempt was invoke Stop before Create. No Action",{appInstanceId:e.context.appInstanceId});this.state.isRunning=!1,this.logger.info("Begin Lifecycle Stop");const t=yield Promise.all([...this.stopHandlers].map((t=>this.handleLifecycleChange(Object.assign(Object.assign({},e),{stage:"stop"}),(e=>t(e)),!1))));this.logger.debug("Completed all stop handlers",{count:this.stopHandlers.size,errorCount:t.filter((({success:e})=>!e)).length})}))}handleDestroy(e){return m(this,void 0,void 0,(function*(){if(this.isDestroyed)return void this.logger.error("An attempt was invoke Destroy multiple times. No Action",{appInstanceId:e.context.appInstanceId});if(!this.isCreated)return void this.logger.error("An attempt was invoke Destroy before Create. No Action",{appInstanceId:e.context.appInstanceId});this.isDestroyed=!0,this.state.isRunning=!1,this.logger.info("Begin Lifecycle Destroy");const{config:t}=this.provider,{success:s}=yield this.handleLifecycleChange(Object.assign(Object.assign({},e),{stage:"destroy"}),(e=>t.onDestroy?t.onDestroy(e):Promise.resolve()),!0);s&&this.sendLifecycleHandlerCompletedMessage(e.context.appInstanceId,"destroy")}))}handleLifecycleChange(e,t,s){return m(this,void 0,void 0,(function*(){let r=!1;try{yield t(e),r=!0}catch(t){const{appInstanceId:r}=e.context;if(s){const s=`An fatal error occurred when handling a ${e.stage} lifecycle action. Closing app`;this.logger.error(s,{appInstanceId:r,error:t}),this.provider.sendFatalError(s,t)}else this.logger.error(`An error occurred when handling a ${e.stage} lifecycle action.`,{appInstanceId:r,error:t})}return{success:r}}))}getLifecycleChangeParams(){return{context:new g(this.provider,this.state.appInstanceId,this.state.appConfig)}}sendLifecycleHandlerCompletedMessage(e,t){this.logger.debug(`Sending lifecycle ${t} completed signal`),this.provider.getProxy().sendLifecycleHandlerCompleted(e,t)}}class y extends h{constructor(e,t){super(e),this.channel=new MessageChannel,this.lifecycleManager=t,this.appLogger=new o({source:"app.appProxy",provider:e})}get proxyType(){return"AppProxy"}sendLifecycleHandlerCompleted(e,t){const s={type:"appLifecycleHandlerCompleted",stage:t,appInstanceId:e};this.sendOrQueueMessageToSubject(s)}tryCloseApp(e,t,s){const r={type:"closeApp",isFatalError:null!=t&&t,message:e,data:s};this.sendOrQueueMessageToSubject(r)}publish(e,t){const s={type:"appPublish",topic:e,data:t};this.sendOrQueueMessageToSubject(s)}initProxy(){var e,t,s;this.status.update({status:"initializing"}),this.channel.port1.onmessage=e=>this.consumerMessageHandler(e),this.connectionTimer=r.start(this.connectionTimeout.bind(this),(e=this.provider.config,Math.max(1,Math.min(6e4,null!==(s=null===(t=e.workspace)||void 0===t?void 0:t.connectionTimeout)&&void 0!==s?s:5e3)))),window.parent.postMessage({type:"connect-app-host-init"},"*",[this.channel.port2]),this.appLogger.debug("Send connect message to configure proxy")}sendMessageToSubject(e){this.channel.port1.postMessage(e)}handleConnectionAcknowledge(){this.connectionTimer.complete()?super.handleConnectionAcknowledge():this.appLogger.error("Workspace connection acknowledge received after timeout. App is not connected to workspace.",{timeout:this.connectionTimer.timeoutMs})}handleMessageFromSubject(e){"appLifecycle"===e.type?this.lifecycleManager.handleLifecycleChangeMessage(e).catch((e=>{this.appLogger.error("An error occurred when invoking handleLifecycleChangeMessage",{error:e})})):super.handleMessageFromSubject(e)}connectionTimeout(e){this.status.update({status:"error",reason:"Workspace connection timeout",details:Object.assign({},e)}),this.publishError({message:"App failed to connect to workspace in the allotted time",key:"workspaceConnectTimeout",details:Object.assign({},e),isFatal:!0,proxyStatus:{initialized:!1}})}addContextToLogger(){const{isRunning:e}=this.lifecycleManager.appState;if(null===document||void 0===document?void 0:document.location){const{origin:t,pathname:s}=document.location;return{appIsRunning:e,app:{origin:t,path:s}}}return{appIsRunning:e,app:{origin:"unknown",path:"unknown"}}}}class v extends s{constructor(e){super({config:e,proxyFactory:()=>this.createProxy()}),this.lifecycleManager=new f(this),this.logger=new o({provider:this,source:"app.provider"})}static init(e){const t=new v(e);return v.initializeProvider(t),{provider:t}}static get default(){return t("AmazonConnectApp has not been initialized")}createProxy(){return new y(this,this.lifecycleManager)}onStart(e,t){this.lifecycleManager.onStart(e,t)}onStop(e){this.lifecycleManager.onStop(e)}offStart(e){this.lifecycleManager.offStart(e)}offStop(e){this.lifecycleManager.offStop(e)}sendCloseAppRequest(e){this.getProxy().tryCloseApp(e,!1)}sendError(e,t){this.logger.error(e,t)}sendFatalError(e,t){this.getProxy().tryCloseApp(e,!0,t)}subscribe(e,t){this.getProxy().subscribe(e,t)}unsubscribe(e,t){this.getProxy().unsubscribe(e,t)}publish(e,t){this.getProxy().publish(e,t)}}const{connectApp:b}=v.init({onCreate:e=>{const{appInstanceId:t}=e.context;console.log("App initialized: ",t)},onDestroy:e=>{console.log("App being destroyed")}})})();